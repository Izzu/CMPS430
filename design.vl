module FSM(start, maxCarNS, maxCarWE, s1, s2, reset, clock, violated, state, violation);
	
	input start, maxCar, s1, s2, reset, clock, violated;
	output [2:0]state;
	output violation;
	reg[2:0]state;
	reg[1:0] cState, nState;
	parameter RR=0, GR=1, YR=2, RR2=3, RG=4, RY=5; 	//1st letter is for N & S, 2nd is for W & E

	always@(state or start or maxCar)
		begin:Caluculate_Next_State
			case(cState)
				RR:begin
					if(start) nState = GR;
					else nState = RR;
					if(violated) violation = 1;
					else violation = 0;
					end

				GR:begin
					nState = YR;
					if(maxCarWE) clock = ~clock; 
					if(violated) violation = 1;
					else violation = 0;
					end

				YR:begin
					nState = RR2;
					if(violated) violation = 1;
					else violation = 0;
					end

				RR2:begin
					nState = RG;
					if(violated) violation = 1;
					else violation = 0;
					end

				RG:begin
					nState = RY;
					if(maxCarWE) clock = ~clock;
					if(violated) violation = 1;
					else violation = 0; 
					end

				RY:begin
					nState = RR;
					if(violated) violation = 1;
					else violation = 0;
					end

				default: nState = RR;
			endcase
		end

	always@(posedge clock or posedge reset)
		begin:RegGen
			if(reset) state = RR;
			else cState = nState;
		end

	always@(state)
		begin:PrintOut
			case(cState)
				'RR: state = 3'b000;
				'GR: state = 3'b001;
				'YR: state = 3'b010;
				'RR2: state = 3'b011;
				'RG: state = 3'b100;
				'RY: state = 3'b101;
				default: state = 3'b111;
			endcase
		end

endmodule;