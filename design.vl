module FSM(N, S, W, E, start, maxCar, s1, s2, wait, reset, state);
	
	input N, S, W, E, start, maxCar, s1, s2, wait, reset;
	output [2:0]state;
	reg[2:0]state;
	reg[1:0] cState, nState;
	parameter RR=0, GR=1, YR=2, RR2=3, RG=4, RY=5; 	//1st letter is for N & S, 2nd is for W & E

	always@(state or start or maxCar or wait)
		begin:Caluculate_Next_State
			case(cState)
				RR:begin
					if(start) nState = GR;
					else nState = RR;
					end

				GR:begin
					if(maxCar) nState = YR;
					elseif(wait) nState = GR;
					else nState = GG;
					end

				YR:begin
					nState = RR2;
					end

				RR2:begin
					nState = RG;
					end

				RG:begin
					if(maxCar) nState = RY;
					elseif(wait) nState = RG;
					else nState = RY;
					end

				RY:begin
					nState = RR;
					end

				default: nState = RR;
			endcase
		end

	always@(posedge wait or posedge reset)
		begin:RegGen
			if(reset) state = RR;
			else state = nState;
		end

	always@(state)
		begin:PrintOut
			case(cState)
				'RR: state = 3'b000;
				'GR: state = 3'b001;
				'YR: state = 3'b010;
				'RR2: state = 3'b011;
				'RG: state = 3'b100;
				'RY: state = 3'b101;
				default: state = 3'b111;
			endcase
		end

endmodule;